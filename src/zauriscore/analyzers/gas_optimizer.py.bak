from typing import List, Dict, Any, Optional
import re
import logging
from dataclasses import dataclass

# Set up logging
logger = logging.getLogger(__name__)

@dataclass
class GasOptimization:
    issue: str
    location: str
    severity: str  # 'low', 'medium', 'high'
    suggestion: str
    potential_saving: str  # Estimated gas saving
    category: str = 'general'  # e.g., 'storage', 'loop', 'math'
    matched_code: str = ''  # The actual code that matched the pattern
    example_before: str = ''  # Example of code before optimization
    example_after: str = ''   # Example of code after optimization
    rationale: str = ''       # Explanation of why this optimization works

class GasOptimizationAnalyzer:
    def __init__(self):
        self.optimizations = []
        self.patterns = [
    {
        'pattern': r'(?:(?:\s*\w+\s+)?(?:uint(?:8|16|32|64|128|256)?)\s+\w+\s*;.*\n){2,}(?:\s*\w+\s+)?(?:uint(?:8|16|32|64|128|256)?)\s+\w+\s*;',
        'issue': r'Multiple small uints that could be packed',
        'severity': r'medium',
        'suggestion': r'Group smaller uints together to use storage slots more efficiently',
        'saving': r'~2000-5000 gas per slot saved',
        'category': r'storage',
        'example_before': 'uint256 public a;\n    uint256 public b;\n    uint8 public c;',
        'example_after': '// Consider packing smaller uints together\\n    uint256 public a;\\n    uint256 public b;\\n    uint8 public c;\\n    // Could be packed with other small uints',
        'rationale': r'Multiple small uints can be packed into a single storage slot to save gas',
    },
    {
        'pattern': r'bytes\s+\w+\s*=\s*new\s+bytes\s*\(\s*\d+\s*\)',
        'issue': r'Dynamic bytes array in storage',
        'severity': r'high',
        'suggestion': r'Use bytes32 or smaller fixed-size bytes if the size is known and <= 32 bytes',
        'saving': r'~20000 gas per operation',
        'category': r'storage',
        'example_before': r'bytes data = new bytes(20);',
        'example_after': r'bytes20 data;  // For fixed-size 20-byte data',
        'rationale': r'Fixed-size bytes (bytes1 to bytes32) are more gas efficient than dynamic bytes arrays',
    },
]+\)\s+(public\s+)?(\w+)\s*;',
                'issue': 'Public mapping with no external usage',
                'severity': 'medium',
                'suggestion': 'Consider making the mapping private if not needed externally',
                'saving': '~2000 gas per read',
                'category': 'storage',
                'example_before': 'mapping(address => uint) public balances;',
                'example_after': 'mapping(address => uint) private _balances;',
                'rationale': 'Public variables generate implicit getter functions which cost gas'
            },
            {
                'pattern': r'struct\s+(\w+?)\s*{([^}]*)}',
                'issue': 'Inefficient struct packing',
                'severity': 'high',
                'suggestion': 'Re-order struct fields to pack variables more efficiently (32-byte slots)',
                'saving': '~2000-5000 gas per slot',
                'category': 'storage',
                'example_before': 'struct User {\n    bool isActive;\n    uint256 id;\n    address user;\n    uint8 age;\n}',
                'example_after': 'struct User {\n    address user;\n    uint256 id;\n    uint8 age;\n    bool isActive;\n}',
                'rationale': 'Packing smaller types together can reduce storage slots used'
            },
            {
                'pattern': r'(uint(8|16|32|64|128|256)\s+\w+;\s*){2,}uint(8|16|32|64|128|256)\s+\w+;',
                'issue': 'Multiple small uints that could be packed',
                'severity': 'medium',
                'suggestion': 'Group smaller uints together to use storage slots more efficiently',
                'saving': '~2000-5000 gas per slot saved',
                'category': 'storage',
                'example_before': 'uint256 public a;\n    uint256 public b;\n    uint8 public c;',
                'example_after': '// Consider packing smaller uints together\n    uint256 public a;\n    uint256 public b;\n    uint8 public c;\n    // Could be packed with other small uints',
                'rationale': 'Multiple small uints can be packed into a single storage slot to save gas'
            },
            {
                'pattern': r'bytes\s+\w+\s*=\s*new\s+bytes\(\s*\d+\s*\)',
                'issue': 'Dynamic bytes array in storage',
                'severity': 'high',
                'suggestion': 'Use bytes32 or smaller fixed-size bytes if the size is known and <= 32 bytes',
                'saving': '~20000 gas per operation',
                'category': 'storage',
                'example_before': 'bytes data = new bytes(20);',
                'example_after': 'bytes20 data;  // For fixed-size 20-byte data',
                'rationale': 'Fixed-size bytes (bytes1 to bytes32) are more gas efficient than dynamic bytes arrays'
            },
            {
                'pattern': r'mapping\([^)]+\)\s+public\s+\w+\s*=\s*[^;]+;',
                'issue': 'Public mapping with initial value',
                'severity': 'medium',
                'suggestion': 'Initialize mappings in the constructor instead',
                'saving': '~20000 gas per deployment',
                'category': 'storage',
                'example_before': 'mapping(address => bool) public whitelist = {0x123...: true};',
                'example_after': 'mapping(address => bool) public whitelist;\nconstructor() {\n    whitelist[0x123...] = true;\n}',
                'rationale': 'Initializing mappings at declaration wastes gas as they are initially empty'
            },
            
            # Loop Optimization
            {
                'pattern': r'for\s*\([^;]*;([^;]*);[^)]*\)\s*\{[^}]*\s*storage\s+\w+\s*\[',
                'issue': 'Storage array in loop',
                'severity': 'high',
                'suggestion': 'Cache storage array in memory before loop',
                'saving': '~100-1000 gas per iteration',
                'category': 'loop'
            },
            {
                'pattern': r'for\s*\([^;]*;([^;]*);[^)]*\)\s*\{[^}]*\s*\w+\s*\+\+',
                'issue': 'Post-increment in loop',
                'severity': 'low',
                'suggestion': 'Use pre-increment (++i) instead of post-increment (i++)',
                'saving': '~5 gas per iteration',
                'category': 'loop'
            },
            
            # Math Operations
            {
                'pattern': r'\b(\w+)\s*\*\s*2\b',
                'issue': 'Multiplication by 2',
                'severity': 'low',
                'suggestion': 'Replace x * 2 with x << 1',
                'saving': '~3 gas per operation',
                'category': 'math'
            },
            {
                'pattern': r'\b(\w+)\s*==\s*0\b',
                'issue': 'Zero comparison',
                'severity': 'low',
                'suggestion': 'Replace x == 0 with x <= 0 for non-negative values',
                'saving': '~3 gas per operation',
                'category': 'math'
            },
            
            # Function Optimization
            {
                'pattern': r'function\s+\w+\s*\([^)]*\)\s*(public|external)',
                'issue': 'Function visibility not specified',
                'severity': 'low',
                'suggestion': 'Specify visibility (public, external, internal, private)',
                'saving': '~100-200 gas per call',
                'category': 'function'
            },
            {
                'pattern': r'function\s+\w+\s*\([^)]*\)\s*external\s*\{',
                'issue': 'External function with no modifiers',
                'severity': 'medium',
                'suggestion': 'Add access control or reentrancy guard if needed',
                'saving': 'N/A (Security)',
                'category': 'function'
            },
            
            # Memory vs Storage
            {
                'pattern': r'storage\s+\w+\s*=\s*\w+\s*;',
                'issue': 'Direct storage assignment',
                'severity': 'medium',
                'suggestion': 'Consider using memory variables for intermediate calculations',
                'saving': '~5000-20000 gas per operation',
                'category': 'memory'
            },
            
            # Event Optimization
            {
                'pattern': r'event\s+\w+\s*\([^)]*\)\s*;',
                'issue': 'Event parameter not indexed',
                'severity': 'low',
                'suggestion': 'Add indexed keyword to event parameters for filtering',
                'saving': '~100-500 gas per event',
                'category': 'event'
            },
            
            # Error Handling
            {
                'pattern': r'require\([^,)]+,\s*\"[^\"]*\"\)',
                'issue': 'String error message in require',
                'severity': 'low',
                'suggestion': 'Use custom errors instead of string error messages',
                'saving': '~1000-5000 gas per revert',
                'category': 'error'
            },
            
            # Constructor Optimization
            {
                'pattern': r'constructor\s*\([^)]*\)\s*\{',
                'issue': 'Constructor with complex logic',
                'severity': 'medium',
                'suggestion': 'Move complex logic to an initialization function',
                'saving': 'Varies',
                'category': 'constructor'
            },
            
            # Unchecked Blocks
            {
                'pattern': r'unchecked\s*\{',
                'issue': 'Unchecked block usage',
                'severity': 'high',
                'suggestion': 'Ensure arithmetic operations cannot overflow/underflow',
                'saving': '~20-40 gas per operation',
                'category': 'math'
            },
            
            # View/Pure Functions
            {
                'pattern': r'function\s+\w+\s*\([^)]*\)\s*(public|internal)',
                'issue': 'Function could be view/pure',
                'severity': 'low',
                'suggestion': 'Mark function as view/pure if it doesn\'t modify state',
                'saving': '~100-500 gas per call',
                'category': 'function'
            }
        ]
    

    def analyze(self, source_code: str) -> List[GasOptimization]:
        """Analyze the source code for gas optimizations"""
        optimizations = []
        
        # Normalize line endings and clean up the source code
        source_code = source_code.replace('\r\n', '\n').replace('\r', '\n')
        
        # Debug: Print first 200 chars of source code
        print("\n" + "="*80)
        print("DEBUG - First 200 chars of source code:")
        print(source_code[:200])
        print("="*80 + "\n")
        
        for pattern_info in self.patterns:
            try:
                pattern = pattern_info['pattern']
                print(f"\nTrying pattern: {pattern}")
                print(f"For issue: {pattern_info['issue']}")
                
                # Compile pattern with MULTILINE and DOTALL flags
                compiled_pattern = re.compile(pattern, re.MULTILINE | re.DOTALL)
                matches = list(compiled_pattern.finditer(source_code))
                print(f"Found {len(matches)} matches")
                
                for match in matches:
                    try:
                        print(f"Match found at position {match.start()}")
                        print(f"Matched text: {match.group(0)[:100]}")
                        
                        # Get the line number and surrounding code
                        line_start = source_code[:match.start()].count('\n') + 1
                        line_end = source_code[:match.end()].count('\n') + 1
                    except Exception as e:
                        print(f"Error processing match: {e}")
                        continue
                    
                    # Get the matched code block
                    matched_code = match.group(0).strip()
                    if len(matched_code) > 100:  # Truncate long matches
                        matched_code = matched_code[:97] + '...'
                    
                    # Create detailed location info
                    location = f"Lines {line_start}-{line_end}"
                    
                    # Create optimization suggestion with enhanced details
                    opt = GasOptimization(
                        issue=pattern_info['issue'],
                        location=location,
                        severity=pattern_info['severity'],
                        suggestion=(
                            f"{pattern_info['suggestion']}\n\n"
                            f"Example before:\n{pattern_info.get('example_before', 'N/A')}\n\n"
                            f"Example after:\n{pattern_info.get('example_after', 'N/A')}\n\n"
                            f"Rationale: {pattern_info.get('rationale', 'N/A')}"
                        ),
                        potential_saving=pattern_info['saving'],
                        category=pattern_info.get('category', 'general'),
                        matched_code=matched_code
                    )
                    optimizations.append(opt)
                    
            except Exception as e:
                # Log pattern matching errors but continue with other patterns
                import traceback
                print(f"Error in pattern {pattern_info.get('issue', 'unknown')}: {e}")
                traceback.print_exc()
        
        # Check for common gas patterns
        self._check_common_patterns(source_code, optimizations)
        
        return optimizations
    
    def _check_common_patterns(self, source_code: str, optimizations: List[GasOptimization]):
        """Check for common gas optimization patterns"""
        # Check for unchecked blocks
        unchecked_blocks = len(re.findall(r'unchecked\s*\{', source_code))
        if unchecked_blocks > 5:  # Arbitrary threshold
            optimizations.append(GasOptimization(
                issue='Multiple unchecked blocks',
                location='Multiple locations',
                severity='medium',
                suggestion='Ensure all arithmetic operations are safe when using unchecked blocks',
                potential_saving='~20-40 gas per operation'
            ))
        
        # Check for external functions that could be marked as view/pure
        external_no_state_change = len(re.findall(r'function\s+\w+\s*\([^)]*\)\s+external', source_code))
        if external_no_state_change > 0:
            optimizations.append(GasOptimization(
                issue='External functions not marked as view/pure',
                location='Multiple locations',
                severity='low',
                suggestion='Mark view/pure functions to save gas on calls',
                potential_saving='~200-2000 gas per call'
            ))
    
    def generate_report(self, optimizations: List[GasOptimization], format: str = 'text') -> Dict[str, Any]:
        """Generate a structured report of gas optimizations
        
        Args:
            optimizations: List of GasOptimization objects
            format: Output format ('text' or 'dict')
            
        Returns:
            Dict containing the report data or formatted string
        """
        # Group optimizations by category and severity
        by_category = {}
        by_severity = {
            'high': [],
            'medium': [],
            'low': []
        }
        
        for opt in optimizations:
            # Initialize category if not exists
            if opt.category not in by_category:
                by_category[opt.category] = []
            
            # Create optimization entry
            opt_dict = {
                'issue': opt.issue,
                'location': opt.location,
                'suggestion': opt.suggestion,
                'potential_saving': opt.potential_saving,
                'matched_code': opt.matched_code,
                'example_before': getattr(opt, 'example_before', ''),
                'example_after': getattr(opt, 'example_after', ''),
                'rationale': getattr(opt, 'rationale', '')
            }
            
            # Add to category and severity groups
            by_category[opt.category].append(opt_dict)
            by_severity[opt.severity].append(opt_dict)
        
        # Calculate summary statistics
        summary = {
            'total': len(optimizations),
            'by_severity': {
                'high': len(by_severity['high']),
                'medium': len(by_severity['medium']),
                'low': len(by_severity['low'])
            },
            'by_category': {cat: len(opts) for cat, opts in by_category.items()}
        }
        
        # Format the report based on requested format
        if format == 'dict':
            return {
                'summary': summary,
                'by_severity': by_severity,
                'by_category': by_category
            }
        else:
            # Format as text
            report = []
            report.append("="*80)
            report.append("GAS OPTIMIZATION REPORT")
            report.append("="*80)
            
            # Add summary
            report.append("\nSUMMARY:")
            report.append(f"Total optimizations: {summary['total']}")
            report.append(f"High: {summary['by_severity']['high']}, "
                        f"Medium: {summary['by_severity']['medium']}, "
                        f"Low: {summary['by_severity']['low']}")
            
            # Add by category
            report.append("\nBY CATEGORY:")
            for cat, count in summary['by_category'].items():
                report.append(f"- {cat.title()}: {count}")
            
            # Add details by severity
            for severity in ['high', 'medium', 'low']:
                if by_severity[severity]:
                    report.append(f"\n{'='*10} {severity.upper()} SEVERITY {'='*10}")
                    for i, opt in enumerate(by_severity[severity], 1):
                        report.append(f"\n{i}. {opt['issue']} ({opt['location']})")
                        report.append(f"   Potential savings: {opt['potential_saving']}")
                        report.append(f"\n   Matched code:\n   {opt['matched_code']}")
                        if opt.get('example_before'):
                            report.append("\n   Example before:")
                            for line in opt['example_before'].split('\n'):
                                report.append(f"     {line}")
                        if opt.get('example_after'):
                            report.append("\n   Example after:")
                            for line in opt['example_after'].split('\n'):
                                report.append(f"     {line}")
                        report.append(f"\n   Suggestion: {opt['suggestion']}")
                        if opt.get('rationale'):
                            report.append(f"\n   Rationale: {opt['rationale']}")
                        report.append("")
            
            return '\n'.join(report)
